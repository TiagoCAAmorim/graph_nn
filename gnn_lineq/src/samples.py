"""
Module that holds classes to build a Linear Equations Dataset.

Classes:
--------
- DynamicGraphDataset: Custom dataset for samples generated dinamically.
- LinEqSample: Class that generates Linear Equations samples.
"""
import numpy as np
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

import torch
import torch_geometric as tg

class DynamicGraphDataset(tg.data.Dataset): # pylint: disable=abstract-method
    """
    Custom dataset for samples generated dinamically.

    Each sample is generated by a user defined function. The dataset length
    is defined just to keep track of the number of samples generated in
    each epoch. The dataset is not stored in memory, and samples will vary
    from epoch to epoch.

    Attributes:
    -----------
    - dataset_len: int. Dataset length.
    - sample_function: function. Function that generates a sample.
    - transform: torch_geometric.transforms. Transform to apply to the dataset.
    - pre_transform: torch_geometric.transforms. Pre-transform to apply to the dataset.
    - kwargs: dict. Keyword arguments to pass to the sample function.
    """
    def __init__(self, dataset_len, sample_function, transform=None, pre_transform=None, **kwargs):
        super().__init__('.', transform, pre_transform)
        self.n = dataset_len
        self.sample_function = sample_function
        self.kwargs = kwargs

    def len(self):
        return self.n

    def get(self, idx):
        return self.sample_function(**self.kwargs)


class LinEqSample():
    """
    Class that generates Linear Equations samples.

    The main diagonal is always 1. The off-diagonal elements are drawn from
    a uniform distribution. The mean of the absolute values of the off-diagonal
    elements is given by the `off_diagonal_abs_mean` parameter. The range of
    the uniform distribution is given by the `uniform_range` parameter.
    The rank of the matrix is given by the `rank` parameter.
    If the `symmetric` parameter is True, the matrix is symmetric.

    The number of diagonals with non-null values is given by the `diagonals`
    parameter. If it is an odd number, the lower triangle of the matrix has one
    more diagonal than the upper triangle.


    Attributes:
    -----------
    - rank (int): Rank of the square matrix. Default is 5.
    - diagonals (int): Number of diagonals with non-null values.
        Default is 5.
    - off_diagonal_abs_mean (float): Mean of the absolute values of the
        off-diagonal elements. Default is 0.5.
    - symmetric (bool): If True, the matrix is symmetric. Default is False.
    - width_range (tuple): Range of possbible values for the width of the
        uniform distribution used to create the matrix of coefficients.
        Default is (0.1,10.).

    Methods:
    --------
    - number_generator: Generates random numbers with a probabilistic range.
    - get: Generates a linear system sample.
    - calculate_residual: Calculates the residual of the linear system.
    - sparse_to_graph: Generates a graph from the linear system.
    """

    def __init__(self, **kwargs):
        self.rank = kwargs.get('rank', 5)
        if self.rank < 3:
            raise ValueError("Rank must be at least 3.")

        self.diagonals = kwargs.get('diagonals', 5)
        if self.diagonals > 2*self.rank - 1:
            raise ValueError(f"Diagonals must be at most 2*rank - 1 ({2*self.rank - 1}).")

        self.off_diagonal_abs_mean = kwargs.get('off_diagonal_abs_mean', 0.5)
        if self.off_diagonal_abs_mean < 0:
            raise ValueError("Off-diagonal mean must be non-negative.")

        self.symmetric = kwargs.get('symmetric', False)
        if self.symmetric and self.diagonals % 2 == 0:
            raise ValueError("Symmetric matrices must have an odd number of diagonals.")

        self.width_range = kwargs.get('width_range', (0.1,10.))
        if self.width_range[0] > self.width_range[1]:
            self.width_range = (self.width_range[1], self.width_range[0])

        self._params = self._get_params()


    def _get_params(self):
        params = {
            'main_diag': np.ones(self.rank),
            'n_diag': [self.rank-(i+1)//2 for i in range(self.diagonals)],
            'offsets': [i//2 if i % 2 == 0 else -(i//2 + 1) for i in range(self.diagonals)],
            'n_': 2 if self.symmetric else 1,
        }
        params['n_values'] = sum(params['n_diag'][1:])//params['n_']
        cum_sum = np.cumsum([0] + params['n_diag'][1::params['n_']])[:-1]
        params['i_diag'] = np.array([item for item in cum_sum for _ in range(params['n_'])])

        return params


    @staticmethod
    def number_generator(size=1, width=(1.,1.)):
        """
        Generates random numbers with a probabilistic range.

        The mean of the random numbers is drawn from a uniform distribution
        between -1 and 1. The range (or width) of the random numbers around the
        mean is drawn from a uniform distribution, with range equal to the
        `width` parameter.

        Parameters:
        -----------
        - size (int): Number of random numbers to generate.
        - width (tuple): Limits of the width around the mean for the random.
            Draws from a uniform distribution.
        """
        rng = np.random.default_rng()
        mean = rng.uniform(low=-1, high=1, size=1)
        width_ = rng.uniform(low=width[0], high=width[1], size=1)
        return rng.uniform(low=mean-0.5*width_, high=mean+0.5*width_, size=size)


    def _get_matrix(self):
        values = LinEqSample.number_generator(
            size=self._params['n_values'],
            width=self.width_range)

        mean_abs = np.abs(values).mean()
        alpha = self.off_diagonal_abs_mean / mean_abs
        values = values * alpha

        data = [self._params['main_diag']]
        for i in range(self.diagonals-1):
            i_0 = self._params['i_diag'][i]
            i_1 = i_0 + self._params['n_diag'][i+1]
            data.append(values[i_0:i_1])

        return diags(data, self._params['offsets'], format='csr')


    def get(self, max_error=0, max_iter=1000, throw_error=True):
        """
        Get a linear system sample.

        Arguments:
        ----------
        - max_error (float): Maximum error allowed for the linear system.
            The root mean square error is used to calculate the error.
            If equal to zero, the erros is not checked. Default is 0.
        - max_iter (int): Maximum number of iterations to generate a linear
            system. Default is 1000.
        - throw_error (bool): If True, raises an error if the maximum number
            of iterations is reached. If False the 'best' sample is returned.
            Default is True.

        Returns:
        --------
        - matrix_a (scipy.sparse.csr_matrix): Matrix of coefficients.
        - x_true (np.ndarray): True solution.
        - b (np.ndarray): Right-hand side of the linear system.
        """

        best_error = np.inf
        best_sample = None

        for _ in range(max_iter):
            matrix_a = self._get_matrix()
            x_true = LinEqSample.number_generator(
                size=self.rank,
                width=(1.,1.))
            b = matrix_a.dot(x_true)

            if max_error == 0:
                return (matrix_a, x_true, b)
            error = LinEqSample.calculate_residual(matrix_a, x_true, b, aggr='rms')
            if error < max_error:
                return (matrix_a, x_true, b)
            if error < best_error:
                best_error = error
                best_sample = (matrix_a, x_true, b)

        if throw_error:
            raise ValueError("Could not generate a linear system with the desired error.")
        return best_sample


    def get_graph(self, max_error=0, max_iter=1000, throw_error=True):
        """
        Get a graph from a linear system sample.

        Arguments:
        ----------
        - max_error (float): Maximum error allowed for the linear system.
            The root mean square error is used to calculate the error.
            If equal to zero, the erros is not checked. Default is 0.
        - max_iter (int): Maximum number of iterations to generate a linear
            system. Default is 1000.
        - throw_error (bool): If True, raises an error if the maximum number
            of iterations is reached. If False the 'best' sample is returned.
            Default is True.

        Returns:
        --------
        - matrix_a (scipy.sparse.csr_matrix): Matrix of coefficients.
        - x_true (np.ndarray): True solution.
        - b (np.ndarray): Right-hand side of the linear system.
        """
        matrix, x_true, b = self.get(
            max_error=max_error,
            max_iter=max_iter,
            throw_error=throw_error
        )
        return LinEqSample.sparse_to_graph(matrix, x_true, b)


    @staticmethod
    def calculate_residual(matrix, x_true, b, aggr=None):
        """
        Calculate the residual of the linear system.

        Arguments:
        ----------
        - matrix (scipy.sparse.csr_matrix): Matrix of coefficients.
        - x_true (np.ndarray): True solution.
        - b (np.ndarray): Right-hand side of the linear system.
        - aggr (str): Aggregation method for the residual. Options are 'max',
            'mean', and 'rms'. If None, returns the vector. Default is None.

        Returns:
        --------
        - np.ndarray or float: Residual of the linear system.
        """
        x_solve = spsolve(matrix, b)
        residual = np.abs(x_solve - x_true)
        if aggr is None:
            return residual
        if aggr == 'max':
            return residual.max()
        if aggr == 'mean':
            return residual.mean()
        if aggr == 'rms':
            return np.sqrt(np.mean(np.square(residual)))
        raise ValueError("Invalid aggregation method.")


    @staticmethod
    def sparse_to_graph(matrix, x_true, b):
        """
        Generate graph from sparse matrix system of equations

        Arguments:
        ----------
        - matrix (scipy.sparse.csr_matrix): Matrix of coefficients.
        - x_true (np.ndarray): True solution.
        - b (np.ndarray): Right-hand side of the linear system.

        Returns:
        --------
        - tg.data.Data: Graph data object.
        """
        return tg.data.Data(
            x=torch.tensor(b).unsqueeze(1).to(torch.float32),
            edge_index=torch.tensor(np.array(matrix.nonzero())).to(torch.int64),
            edge_attr=torch.tensor(matrix.data).unsqueeze(1).to(torch.float32),
            y=torch.tensor(x_true).unsqueeze(1).to(torch.float32)
            )


def test_sample():
    """Test sample generation."""
    samples = LinEqSample(
        rank=5,
        diagonals=4,
        off_diagonal_abs_mean=0.5,
        symmetric=False,
        width_range=(0.1,10.)
    )

    matrix, x_true, b = samples.get(max_error=1E-6, max_iter=1000, throw_error=True)

    print('Matrix:')
    print(matrix.toarray())
    print('x_true:')
    print(x_true)
    print('b:')
    print(b)
    print('Residual:')
    residual = LinEqSample.calculate_residual(matrix, x_true, b)
    print(residual)
    residual = LinEqSample.calculate_residual(matrix, x_true, b, aggr='max')
    print('max: ',residual)
    residual = LinEqSample.calculate_residual(matrix, x_true, b, aggr='mean')
    print('mean: ',residual)
    residual = LinEqSample.calculate_residual(matrix, x_true, b, aggr='rms')
    print('rms: ',residual)


def test_dataset():
    """Test creating a dataset."""
    samples = LinEqSample(
        rank=50,
        diagonals=4,
        off_diagonal_abs_mean=0.5,
        symmetric=False,
        width_range=(0.1,10.)
    )

    dataset = DynamicGraphDataset(
        dataset_len=100,
        sample_function=samples.get_graph,
        max_error=1E-6,
        max_iter=1000,
        throw_error=False
    )

    print('Dataset length:', len(dataset))
    print('Sample 0:')
    print(dataset[0])


if __name__ == '__main__':
    # test_sample()
    test_dataset()
