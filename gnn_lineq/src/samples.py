"""Module that holds classes for a Linear Equations Dataloader."""
import numpy as np
from numpy import random
from scipy.sparse import diags
from scipy.sparse.linalg import spsolve

import torch
import torch.nn.functional as F

import torch_geometric as tg
from torch_geometric.nn import GCNConv
from torch_geometric.loader import DataLoader
from torch_geometric.utils.convert import to_networkx


class DynamicGraphDataset(tg.data.Dataset):
    """
    Custom dataset for samples generated dinamically.

    Each sample is generated by a user defined function. The dataset length
    is defined just to keep track of the number of samples generated in
    each epoch. The dataset is not stored in memory, and samples will vary
    from epoch to epoch.

    Attributes:
    -----------
    - dataset_len: int. Dataset length.
    - sample_function: function. Function that generates a sample.
    - transform: torch_geometric.transforms. Transform to apply to the dataset.
    - pre_transform: torch_geometric.transforms. Pre-transform to apply to the dataset.
    - kwargs: dict. Keyword arguments to pass to the sample function.
    """
    def __init__(self, dataset_len, sample_function, transform=None, pre_transform=None, **kwargs):
        super(DynamicGraphDataset, self).__init__('.', transform, pre_transform)
        self.n = dataset_len
        self.sample_function = sample_function
        self.kwargs = kwargs

    def len(self):
        return self.n

    def get(self, idx):
        return self.sample_function(**self.kwargs)


# options = {
#     'n': 100,
#     'number_generator': number_generator,
#     'rank': 5,
#     'off_diagonal_abs_mean': 1.0,
#     'symmetric': False,
#     'uniform_range': (0.1,10.)
# }

class LinEqSample():
    """
    Class that generates Linear Equations samples.

    The main diagonal is always 1. The off-diagonal elements are drawn from
    a uniform distribution. The mean of the absolute values of the off-diagonal
    elements is given by the `off_diagonal_abs_mean` parameter. The range of
    the uniform distribution is given by the `uniform_range` parameter.
    The rank of the matrix is given by the `rank` parameter.
    If the `symmetric` parameter is True, the matrix is symmetric.

    The number of diagonals with non-null values is given by the `diagonals`
    parameter. If it is an odd number, the lower triangle of the matrix has one
    more diagonal than the upper triangle.


    Attributes:
    -----------
    - rank: int. Rank of the square matrix. Default is 5.
    - diagonals: int. Number of diagonals with non-null values.
        Default is 5.
    - off_diagonal_abs_mean: float. Mean of the absolute values of the
        off-diagonal elements. Default is 0.5.
    - symmetric: bool. If True, the matrix is symmetric. Default is False.
    - uniform_range: tuple. Range of the uniform distribution for the
        random numbers. Default is (0.1,10.).
    """

    def __init__(self, **kwargs):
        self.rank = kwargs.get('rank', 5)
        if self.rank < 3:
            raise ValueError("Rank must be at least 3.")

        self.diagonals = kwargs.get('diagonals', 5)
        if self.diagonals > 2*self.rank - 1:
            raise ValueError(f"Diagonals must be at most 2*rank - 1 ({2*self.rank - 1}).")

        self.off_diagonal_abs_mean = kwargs.get('off_diagonal_abs_mean', 0.5)
        if self.off_diagonal_abs_mean < 0:
            raise ValueError("Off-diagonal mean must be non-negative.")

        self.symmetric = kwargs.get('symmetric', False)
        if self.symmetric and self.diagonals % 2 == 0:
            raise ValueError("Symmetric matrices must have an odd number of diagonals.")

        self.width_range = kwargs.get('width_range', (0.1,10.))
        if self.width_range[0] > self.width_range[1]:
            self.width_range = (self.width_range[1], self.width_range[0])

        self._params = self._get_params()


    def _get_params(self):
        params = {
            'main_diag': np.ones(self.rank),
            'n_diag': [self.rank-(i+1)//2 for i in range(self.diagonals)],
            'offsets': [i//2 if i % 2 == 0 else -(i//2 + 1) for i in range(self.diagonals)],
            'n_': 2 if self.symmetric else 1,
        }
        params['n_values'] = sum(params['n_diag'][1:])//params['n_']
        cum_sum = np.cumsum([0] + params['n_diag'][1::params['n_']])[:-1]
        params['i_diag'] = np.array([item for item in cum_sum for _ in range(params['n_'])])

        return params



    @staticmethod
    def number_generator(size=1, width=(1.,1.)):
        """
        Generates random numbers with a probabilistic range.

        The mean of the random numbers is drawn from a uniform distribution
        between -1 and 1. The range (or width) of the random numbers around the
        mean is drawn from a uniform distribution, with range equal to the
        `width` parameter.

        Parameters:
        size (int): Number of random numbers to generate.
        width (tuple): Limits of the width around the mean for the random.
            Draws from a uniform distribution.
        """
        rng = np.random.default_rng()
        mean = rng.uniform(low=-1, high=1, size=1)
        width_ = rng.uniform(low=width[0], high=width[1], size=1)
        return rng.uniform(low=mean-0.5*width_, high=mean+0.5*width_, size=size)


    def _get_matrix(self):
        values = LinEqSample.number_generator(
            size=self._params['n_values'],
            width=self.width_range)

        mean_abs = np.abs(values).mean()
        alpha = self.off_diagonal_abs_mean / mean_abs
        values = values * alpha

        data = [self._params['main_diag']]
        for i in range(self.diagonals-1):
            i_0 = self._params['i_diag'][i]
            i_1 = i_0 + self._params['n_diag'][i+1]
            data.append(values[i_0:i_1])

        return diags(data, self._params['offsets'], format='csr')


    def get(self):
        """Get a linear system sample."""

        matrix_a = self._get_matrix()

        x_true = LinEqSample.number_generator(
            size=self.rank,
            width=(1.,1.))
        b = matrix_a.dot(x_true)

        return (matrix_a, x_true, b)

    @staticmethod
    def _get_residual(matrix, x_true, b):
        x_solve = spsolve(matrix, b)
        residual = x_solve - x_true
        return residual

    @staticmethod
    def _sparse_to_graph(matrix, x_true, b):
        """Generate graph from sparse matrix system of equations."""
        return tg.data.Data(
            x=torch.tensor(b).unsqueeze(1).to(torch.float32),
            edge_index=torch.tensor(np.array(matrix.nonzero())).to(torch.int64),
            edge_attr=torch.tensor(matrix.data).unsqueeze(1).to(torch.float32),
            y=torch.tensor(x_true).unsqueeze(1).to(torch.float32)
            )

def test_sample():
    """Test sample generation."""
    samples = LinEqSample(
        rank=5, diagonals=6, off_diagonal_abs_mean=0.5, symmetric=False, width_range=(0.1,10.))

    matrix, x_true, b = samples.get()
    residual = LinEqSample._get_residual(matrix, x_true, b) # pylint: disable=protected-access
    print('Matrix:')
    print(matrix.toarray())
    print('x_true:')
    print(x_true)
    print('b:')
    print(b)
    print('Residual:')
    print(residual)

if __name__ == '__main__':
    print(__doc__)
    test_sample()
